#ifndef SERVER_CONN_HH
#define SERVER_CONN_HH
#include <stdint.h>
#include <stdlib.h>
#include <vector>
#include <string>
#include <map>
#include "common.hh"
#include "hashtable.hh"

#define container_of(ptr, T, member) \
  ((T *)( (char *)ptr - offsetof(T, member) ))

struct GlobalData {
  HMap db;  // top-level hashtable
};
extern GlobalData g_data;

// KV pair for the top-level hashtable
struct Entry {
  struct HNode node;  // hashtable node
  std::string key;
  std::string val; 
};

struct LookupKey {  // for lookup only
  HNode node;
  std::string key;
};

// Response::status
enum {
  RES_OK  = 0,  // success
  RES_ERR = 1,  // error
  RES_NX  = 2,  // key not found
};

// +--------|---------+
// | status | data... |
// +--------|---------+
struct Response {
  uint32_t status = 0;
  std::vector<uint8_t> data;
};

struct Conn {
  int fd = -1;
  // application's intention, for the event loop
  bool want_read = false;
  bool want_write = false;
  bool want_close = false;
  // buffered input and output
  Buffer incoming;  // data to be parsed by the application
  Buffer outgoing;  // responses generated by the application
};

// Server-side connection management APIs
Conn *handle_accept(int fd);
bool try_process_one_request(Conn *conn);
void handle_write(Conn *conn);
void handle_read(Conn *conn);

// +------|-----|------|-----|------|-----|-----|------+
// | nstr | len | str1 | len | str2 | ... | len | strn |
// +------|-----|------|-----|------|-----|-----|------+

int32_t parse_req(uint8_t const *data, size_t size, std::vector<std::string> &out);
void do_request_and_make_response(std::vector<std::string> &cmd, Buffer &buffer);

#endif